---
sidebar_position: 1
slug: loice_v1.x
---

:::note 修订记录

**2021-9-10** 燕卫博[WindForest@yeah.net] 创建V1.x初始版本。

:::

<br/>

:::info 相关信息

本协议为 **一种基于TCP的上行/下行数据量不对等的指令-数据交互控制协议** ，由 **Turix-CEL联合实验室** 设计。

当前版本：V1.x 设计原型

:::

<br/>

:::caution 注意事项

设计原型用于原理说明，在具体应用场景下使用时可能需要重新评估或修订。

:::

<br/>

## 1 介绍

Loice（Lasting-Voice，恒音）通信协议是为低负载和低吞吐量嵌入式设备设计的一种局域网内TCP应用层交互控制协议。尽管协议支持一对多或多对一的交互访问，但它在一对一的控制需求中更为适合。

Loice协议仅提供一种指令和数据的封装方法，而不具体针对某项业务，应用程序需要自行定义每种指令和数据及它们的含义，指令和数据类型与协议相互解耦，二者得以独立实现。

本文描述了Loice通信协议的指令和数据格式，由于缺乏具体使用场景的限制，协议设计的考量涉及到了较多的方面，诸如版本扩展和保留字段等，因此仅作为设计原型供参考之用，当在具体的业务场景下使用Loice通信协议时，可根据需要对设计原型做适当修改。

:::tip 建议

Loice协议建议：为方便协议族及衍生协议集合的统一管理，凡在本设计原型上做修改得到的协议，在描述时可继承Loice一级名称，并自行决定修改后协议的二级名称，例如“恒音·风鸣”。修改后的协议需在协议正文或附录中增加修改自述章节。

:::

<br/>

## 2 依赖和协议适用

Loice协议为应用层协议，其基于TCP传输层协议，依赖TCP的可靠连接和流式传输等特性，考虑到TCP传输依然有出现错误的可能，Loice在协议帧中增加了必要的校验字段以保证数据和指令的正确性。

下面列出了几种典型的不适合使用本协议的场景：

- 通信双方需要互相发送任意数据，没有主从机的概念；
- 系统的通信链路中存在扮演路由、网桥、缓冲区等角色的转存设备而非双机直达；
- 协议没有覆盖到的其它情况。

Loice的传输基于无符号字节流，因此通信双方必须事先规定传输时使用的字节序，事实上，只要双方设备使用的架构相同，通常不需要考虑字节序问题。考虑到嵌入式设备的架构通常为支持小端模式，因此Loice协议默认采用**小端模式**进行传输，本文也以小端模式进行叙述。

<br/>

## 3 协议

### 3.1 通信双方角色和通信端口

在使用Loice协议的通信系统中，用于发送指令/接收数据的设备称为**Loice主机**，用于接收指令/发送数据的设备称为**Loice从机**。Loice协议规定一个设备仅能在主机或从机的身份中选择一种，而不能同时扮演两个角色（尽管在实现上并不冲突）。

除上报消息外，每一次通信总是由Loice主机向Loice从机发送指令作为起始，从机响应主机的指令而后按照指令的要求启动数据传输。当Loice主机未发送指令时，Loice从机发送的数据可能被丢弃（取决于实现），反之则应被接收并处理。

Loice从机负责建立TCP服务端，默认绑定在 **1102** 端口，Loice主机以TCP客户端连接到从机，一条TCP连接即一个Loice会话。

### 3.2 协议构成和消息类型规定

遵循Loice协议的一条完整的消息称为一个**协议帧**，每协议帧包含一个定长的消息首部和变长的消息体，根据首部“消息类型”字段的不同，消息体分为指令体和数据体两种。消息体为指令体的协议帧称为**指令帧**；消息体为数据体的协议帧称为**数据帧**。

指令帧仅能由Loice主机构建并发送给从机；数据帧仅能由Loice从机构建并发送给主机，当主机需要下发数据给从机时，可以通过“带有变长参数的指令帧”间接实现该功能。向Loice主机发送指令帧和向Loice从机发送数据帧均属于未定义行为，Loice协议设计原型不讨论这些情况。

### 3.3 消息首部

为了在TCP的流式传输中获取一帧完整的协议帧，Loice协议规定了一个定长的消息首部作为每协议帧的起始，所有传输的消息必须至少包含这个首部，以便对端的识别和处理。

```
                               +-----byte 0----|-----byte 1----|-----byte 2----|-----byte 3----+
                               |7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0|
                               +---------------+---------------+---------------+---------------+
                               |                       Head(14-CF-92-5A)                       |
                               +---------------+---------------+---------------+---------------+
                               |                       Head(A0-C0-00-FF)                       |
                               +---------------+---------------+---------------+---------------+
                               |                Source Device ID(Byte00~Byte03)                |
                               +---------------+---------------+---------------+---------------+
                               |                Source Device ID(Byte04~Byte07)                |
                               +---------------+---------------+---------------+---------------+
                               |                Source Device ID(Byte08~Byte11)                |
                               +---------------+---------------+---------------+---------------+
                               |                Source Device ID(Byte12~Byte15)                |
                               +---------------+---------------+---------------+---------------+
                               |                Source Device ID(Byte16~Byte19)                |
                               +---------------+---------------+---------------+---------------+
                               |                Source Device ID(Byte20~Byte24)                |
                               +---------------+---------------+---------------+---------------+
                               |                      Reserved(00H)(4Bytes)                    |
                               +---------------+---------------+---------------+---------------+
                               |              Destination Device ID(Byte00~Byte03)             |
                               +---------------+---------------+---------------+---------------+
                               |              Destination Device ID(Byte04~Byte07)             |
                               +---------------+---------------+---------------+---------------+
                               |              Destination Device ID(Byte08~Byte11)             |
                               +---------------+---------------+---------------+---------------+
                               |              Destination Device ID(Byte12~Byte15)             |
                               +---------------+---------------+---------------+---------------+
                               |              Destination Device ID(Byte16~Byte19)             |
                               +---------------+---------------+---------------+---------------+
                               |              Destination Device ID(Byte20~Byte24)             |
                               +---------------+---------------+---------------+---------------+
                               |                      Reserved(00H)(4Bytes)                    |
                               +---------------+---------------+---------------+---------------+
                               | Proto Version |    Reserved   |    Message Sequence Number    |
                               +---------------+---------------+---------------+---------------+
                               |                 32-bit Message Timestamp(00H)                 |
                               +---------------+---------------+---------------+---------------+
                               |              Reserved For 64-bit Timestamp(00H)               |
                               +---------------+---------------+---------------+---------------+
                               |               Payload Length(All Message Body)                |
                               +---------------+---------------+---------------+---------------+
                               |          Message Type         |  Message Header Check(16-bit) |
                               +---------------+---------------+---------------+---------------+
```

Loice协议消息首部：

- 使用8个固定字节（0xFF00C0A05A92CF14）作为**帧头**，以便于通信双方从连续的字节流中获取到消息的起始位置；
- 使用24（+4保留）字节长度的**源设备ID**和24（+4保留）字节长度的**目的设备ID**作为设备双方的身份识别依据；
- 使用1字节的**协议版本**字段提供对在当前首部原型下的扩展实现的兼容性；
- 使用2字节长度的**消息序列号**供目的设备的指令流记录、指令传输可靠性验证和指令回应等之用；
- 使用4（+4扩展）字节长度的**时间戳**信息可在通信双方具有同步时钟的情况下供双方测试网络延迟、推测对端消息处理性能、消息新旧校验等之用；
- 使用4字节的**荷载长度**字段用于指示后续的消息体（即指令体或数据体）的总长度，为消息的接收方接收变长消息体提供申请缓冲区的所需长度信息；
- 使用2字节的**消息类型**字段用于指示当前首部的消息类型；
- 使用2字节的**首部验证**字段用于确保首部信息的正确性，尤其是其中荷载长度的正确性。

其中，消息类型包括指令类型、指令回应类型、数据类型、数据回应类型和心跳包相关，具体如下（使用C语言枚举定义）：

```c
typedef enum message_type
{
    MSG_TYPE_RESERVED     = 0,
    // ----------------------------------------
    // 指令发送方
    // ----------------------------------------
    CMD_TYPE_NORMAL       = 1,
    CMD_TYPE_NOREPLY      = 2,
    // ----------------------------------------
    // 指令回应
    // ----------------------------------------
    CMD_REPLY_OK          = 3,
    CMD_REPLY_BUSY        = 4,
    CMD_REPLY_NOT_FOUND   = 5,
    CMD_REPLY_WRONG_ID    = 6,
    CMD_REPLY_OLD_CMD     = 7,
    CMD_REPLY_TOO_LONG    = 8,
    CMD_REPLY_TOO_SHORT   = 9,
    CMD_REPLY_WRONG_CHECK = 10,
    CMD_REPLY_WRONG_ARGS  = 11,
    CMD_REPLY_CMD_EMPTY   = 12,
    // ----------------------------------------
    // 数据类型
    // ----------------------------------------
    DATA_TYPE_NORMAL      = 13,
    DATA_TYPE_NOREPLY     = 14,
    DATA_TYPE_REPORT      = 15,
    DATA_TYPE_REPORT_NOREPLY = 16,
    // ----------------------------------------
    // 数据回应
    // ----------------------------------------
    DATA_REPLY_OK          = 17,
    DATA_REPLY_WRONG_ID    = 18,
    DATA_REPLY_WRONG_CHECK = 19,
    // ----------------------------------------
    // 心跳包相关
    // ----------------------------------------
    KAP_TYPE_NORMAL        = 195, /* 0xC3 */
    KAP_TYPE_NOREPLY       = 196, /* 0xC4 */
    KAP_REPLY_OK           = 197,
    KAP_REPLY_WRONG_ID     = 198,
    KAP_REPLY_TOO_LONG     = 199,
}ENUM_MESSAGE_TYPE;
```

有关指令回应的说明详见 **3.6.1 指令回应** 章节；有关数据回应的说明详见 **3.6.2 数据回应** 和 **3.6.4 由从机角色主动发起的数据上报** 章节；有关心跳包相关的说明详见 **3.6.3 应用层KAP** 章节。

对于消息首部包含的字段有以下解释或说明：

- 设备ID字段的必要性

    虽然TCP/IPv4的四元组信息可以在局域网内确定一条唯一的通信连接，但当设备工作在如动态IP、动态设备绑定、设备防伪等场景中时，需要使用额外的内容确保通信的可靠性。

    **当设备ID字段设置为全0时，表示对端应忽略对此字段的检查**（即放弃通信双方身份验证）。

    特别地，Loice协议规定：对于每一条消息，接收端在构建回应消息时都应将源消息的源设备号填充为当前消息的目标设备号；将本机设备号填充为当前消息的源设备号，即便源消息的目的设备号为全0字段也是如此。

- 消息序列号范围

    消息序列号字段**从1开始计数**，溢出后重新从1开始。**当消息序列号为0时，表示对端应忽略对此字段的检查**（即放弃新旧消息验证）。

- 时间戳

    时间戳字段可由用户设计或使用系统时间戳，由于32位时间戳存在2038年问题，因此消息首部保留对64位时间戳的支持。**当通信双方不启用时间戳时，该字段必须设置为0**。

- 荷载长度

    荷载长度字段用于指示在指令首部之后还有多少字节的变长消息。**当一条消息仅有首部时，荷载长度字段必须设置为0**。

- 消息首部校验

    首部校验可使用多种校验方式，只要通信双方支持并遵守即可，默认使用**16-bit和校验**。

### 3.4 指令体

指令体是消息体的一种，每条指令帧均需包含指令体部分。通过消息首部的“荷载长度”字段可实现在指令体中携带变长参数，此时Loice从机应用程序负责实现对该指令帧参数格式的支持。

```
                               +-----byte 0----|-----byte 1----|-----byte 2----|-----byte 3----+
                               |7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0|
                               +---------------+---------------+---------------+---------------+
                               |   Command ID  | Reserved(00H) |         Command Value         |
                               +---------------+---------------+---------------+---------------+
                               |   Command Body Check(16-bit)  |         Reserved(00H)         |
                               +---------------+---------------+---------------+---------------+
                               |                    Variable Length Data                       |
                               |                              ...                              |
                               +---------------+---------------+---------------+---------------+
```

Loice协议指令体部分使用1字节记录**指令ID**，即指令大类；使用2字节记录**指令值**，即指令号。**特别地，Loice协议规定指令ID和指令值不能为0，用作保留**。指令ID和指令值的匹配可组合为应用程序自定义的多种指令类型，支持的不同指令数量最大达255*65535=16711425条，这足以满足一般嵌入式设备的需求。

Loice协议指令体部分还包含用于校验整个指令体（即固定字段+可变长数据）的**指令体校验**字段，该校验可使用多种校验方式，只要通信双方支持并遵守即可，默认使用**16-bit和校验**。

### 3.5 数据体

数据体是消息体的一种，每条数据帧均需包含数据体部分。通过消息首部的“荷载长度”字段可实现数据体的变长传输，此时Loice主机应用程序负责实现对该数据帧变长数据接收的支持。

```
                               +-----byte 0----|-----byte 1----|-----byte 2----|-----byte 3----+
                               |7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0|
                               +---------------+---------------+---------------+---------------+
                               |   Data Type   | Reserved(00H) |        Data Type Value        |
                               +---------------+---------------+---------------+---------------+
                               |     Data Body Check(16-bit)   | Data Sequence Number(16-bit)  |
                               +---------------+---------------+---------------+---------------+
                               |                    Variable Length Data                       |
                               |                              ...                              |
                               +---------------+---------------+---------------+---------------+
```

与指令帧相似，数据帧同样包含1字节长度的**数据类型**字段和2字节长度的**数据类型值**字段，此外还包含2字节长度的**数据序列号**字段。当Loice从机响应Loice主机的一条指令，并向其发起数据传输时，其发送的每条数据帧的数据类型和数据类型值字段都与指令ID和指令值字段相同。**相同“指令ID-指令值”和“数据类型-数据类型值”的组合在通信双方之间构成了一条抽象的指令-数据交互通道。**

当Loice从机发送的数据需要分多个数据帧发送时，这些数据帧的数据序列号应顺序递增，数据序列号计数方法由应用程序决定。

特别地，Loice协议规定：数据类型和数据类型值均为0的数据体为“上报数据”数据帧类型保留（即消息首部中消息类型字段为 **DATA_TYPE_REPORT** 或 **DATA_TYPE_REPORT_NOREPLY** 的协议帧）。

Loice协议数据体部分还包含用于校验整个数据体（即固定字段+可变长数据）正确性的**数据体校验**字段，该校验可使用多种校验方式，只要通信双方支持并遵守即可，默认使用**16-bit和校验**。

### 3.6 其它协议功能

除指令帧和数据帧外，Loice还规定了用于异常处理的指令/数据回应、应用层KAP和消息上报等协议帧规范。

#### 3.6.1 指令回应

对于来自Loice主机的每条指令，Loice从机可根据要求向主机发送指令回应，用于反馈对某指令帧的接收情况。用于指令回应的协议帧仅包含消息首部，没有附加的消息体，表现为首部中的“荷载长度”字段为0。

对于首部消息类型字段为 **CMD_TYPE_NORMAL** 的指令帧，Loice从机支持以下回应内容（可同时见于 **3.3 消息首部** 章节），其中某些判断可能需要应用程序的支持；而对于首部消息类型字段为 **CMD_TYPE_NOREPLY** 的指令帧，无论指令帧是否正确，Loice从机都不会发送回应。

<center>

| 指令回应协议帧的消息类型字段 |                         指令回应含义                         |
| :--------------------------: | :----------------------------------------------------------: |
|         CMD_REPLY_OK         |             成功。指令帧被成功接收，即将送往执行             |
|        CMD_REPLY_BUSY        | 忙状态。当前暂无法执行该指令，可能上一条指令正在执行或资源被占用 |
|     CMD_REPLY_NOT_FOUND      | 未找到指令。未在指令记录表中找到对应的指令，可能该指令未注册 |
|      CMD_REPLY_WRONG_ID      | 错误的设备ID。指令的目的设备号与本机设备号不匹配，指令将被忽略 |
|      CMD_REPLY_OLD_CMD       | 过时的指令。收到的指令序号小于上一次接收到的指令序号，指令将被忽略 |
|      CMD_REPLY_TOO_LONG      |      指令过长。荷载长度超出接收端承受范围，指令将被忽略      |
|     CMD_REPLY_TOO_SHORT      |      指令过短。荷载长度小于合法长度最小值，指令将被忽略      |
|    CMD_REPLY_WRONG_CHECK     |     错误的校验。指令体校验字段值与接收端本地计算结果不符     |
|     CMD_REPLY_WRONG_ARGS     |              错误的参数。指令附加数据非法或无效              |
|     CMD_REPLY_CMD_EMPTY      |        指令体为空。指令帧消息首部的“荷载长度”字段为0         |

</center>

在上述情况外，当发生以下错误时，接收方将直接丢弃协议帧而不产生回应：

- 消息首部的帧头错误；
- 协议版本不支持；
- 消息首部校验失败。

Loice主机在需要时，可根据这些指令回应判断指令帧是否被正确送达。

#### 3.6.2 数据回应

对于来自Loice从机的每条数据，Loice主机可根据要求向从机发送数据回应，用于表示对某数据帧的接收情况。用于数据回应的协议帧仅包含消息首部，没有附加的消息体，表现为首部中的“荷载长度”字段为0。

对于首部消息类型字段为 **DATA_TYPE_NORMAL** 和 **DATA_TYPE_REPORT** 的数据帧，Loice主机支持以下回应内容（可同时见于 **3.3 消息首部** 章节）；而对于首部消息类型字段为 **DATA_TYPE_NOREPLY** 和 **DATA_TYPE_REPORT_NOREPLY** 的数据帧，无论数据帧是否正确，Loice主机都不会发送回应。

<center>

| 数据回应协议帧的消息类型字段 |                         数据回应含义                         |
| :--------------------------: | :----------------------------------------------------------: |
|        DATA_REPLY_OK         |             成功。数据帧被成功接收，即将送往处理             |
|     DATA_REPLY_WRONG_ID      | 错误的设备ID。数据的目的设备号与本机设备号不匹配，指令将被忽略 |
|    DATA_REPLY_WRONG_CHECK    |     错误的校验。数据体校验字段值与接收端本地计算结果不符     |

</center>

在上述情况外，当发生以下错误时，接收方将直接丢弃协议帧而不产生回应：

- 消息首部的帧头错误；
- 协议版本不支持；
- 消息首部校验失败。

数据帧的回应可用于应用程序实现数据的重传机制，并借此保证数据的可靠传输。需要注意的是，数据回应没有对应于数据帧中数据序列号字段的信息，因此Loice从机必须使用其它途径确定需要重传的数据帧序号。另外请注意：通信双方可以任意规定数据体中变长数据的内容和格式，因为Loice协议仅提供一种指令和数据的封装方法，而不具体针对某项业务。

特别地，首部消息类型字段为 **DATA_TYPE_NOREPLY** 和 **DATA_TYPE_REPORT_NOREPLY** 的数据帧属于上报数据，它不需要指令帧与之对应，Loice主机可自行决定是否忽略对上报数据的接收和回应。

#### 3.6.3 应用层KAP

考虑到TCP在长连接时无法获得对端存活状态，Loice协议规定了应用层KAP消息（以下简称KAP）的规范。KAP仅包含消息首部，没有附加的消息体，表现为首部中的“荷载长度”字段为0。

对于一个已经建立的Loice会话，KAP总是由Loice主机定时发起，由Loice从机响应并回复，消息的往复过程即会话的心跳。

对于首部消息类型字段为 **KAP_TYPE_NORMAL** 的KAP，Loice从机支持以下回应内容（可同时见于 **3.3 消息首部** 章节）；而对于首部消息类型字段为 **KAP_TYPE_NOREPLY** 的KAP，无论KAP是否正确，Loice从机都不会发送回应。

<center>

| KAP协议帧的消息类型字段 |                        KAP回应含义                        |
| :---------------------: | :-------------------------------------------------------: |
|      KAP_REPLY_OK       |                       成功接收到KAP                       |
|   KAP_REPLY_WRONG_ID    |        设备号不匹配，因此为错误的KAP，消息将被忽略        |
|   KAP_REPLY_TOO_LONG    | 荷载长度超出接收端承受范围，因此为无效的KAP，消息将被忽略 |

</center>

在上述情况外，当发生以下错误时，接收方将直接丢弃协议帧而不产生回应：

- 消息首部的帧头错误；
- 协议版本不支持；
- 消息首部校验失败。

为了双方都能获知会话的连接状态，Loice协议规定：指令帧和数据帧不能作为对端存在的依据，KAP定时器记录仅能由KAP消息触发更新。这意味着，如果启用KAP，即便指令和数据在传输，Loice主机也必须定时向Loice从机发送KAP消息。特别地，应用程序在设计时，可以考虑令指令帧和数据帧的回应触发KAP定时器记录，因为消息回应的存在证明通信双方交互正常。

#### 3.6.4 由从机角色主动发起的数据上报

在某些情况下，Loice从机需要主动发起通信，以完成请求指令、消息通知、数据定时上报等业务需求。Loice协议为这种由从机主动发起的数据传输规定了“上报数据”数据帧类型。

对于首部消息类型字段为 **DATA_TYPE_REPORT** 和 **DATA_TYPE_REPORT_NOREPLY** 的协议帧，Loice主机将根据实现对其接收并处理：对于前者将生成与数据帧相同的回应消息；对于后者将不发送回应。

特别地，Loice协议规定，“上报数据”数据帧的数据体中，数据类型和数据类型值字段都必须设置为0，以免与其它正常数据混淆。

### 3.7 双机交互过程示例

本节将设计一种通信情景，以说明Loice协议的通信双方交互过程。

现假设某Loice从机设备注册了以下指令：

<center>

| 指令[ID - Value] |              说明              |
| :--------------: | :----------------------------: |
|      1 - 1       |       启动A类型数据传输        |
|      1 - 2       |       停止A类型数据传输        |
|      2 - 1       |         配置设备某参数         |
|      2 - 2       |         获取设备某参数         |
|      3 - 1       | 以无回应方式向设备发送通知指令 |
|      3 - 2       |   以无回应方式获取设备某参数   |
|      0 - 0       |           某数据上报           |

</center>

某一段时间内通信双方发送的协议帧如下图所示。为了使交互过程更清晰，下图中没有展示如指令帧错误、数据重传等情况，并且省略了KAP消息的传递。

<center>

![双机交互过程示例](/img/双机交互过程示例.png)

</center>

交互过程中主机向从机依次执行了上表中的各项指令，从上图可以看出：

- CMD[1-1]在执行过程中，再次发送此指令，设备回复忙状态；
- 对于每条有回应请求的指令或数据，其回应的消息序列号均与源信息消息序列号相同；
- 对于每条没有回应请求的指令或数据（如105号指令和104号数据），对端不发送回应消息；
- 对于上报的数据（0号消息）无需指令与其匹配。

<br/>

## 4 实现参考

### 4.1 主从机协议层结构设计

Loice主机与Loice从机的协议层架构实现参考示例如下图所示：

<center>

![主从机协议层结构](/img/主从机协议层结构.png)

</center>

Loice主机和从机的协议层实现可分为“TCP连接控制”、“协议帧构建与解析”和“应用程序接口”三个部分，框图中的每个小框均可实现为一个对象，以便于解析器、转发器等的管理。另外，考虑到数据帧的数据量可能远大于指令帧的数据量，且嵌入式设备的内存与运算速度可能十分有限，因此Loice主机程序在设计之初必须考虑尽可能减少数据在内存中的拷贝次数以减小内存占用、提升程序性能。

### 4.2 应用程序接口特性

当基于Loice协议设计应用程序时，应用程序业务本身无需考虑协议层的实现，仅需约定并建立抽象的指令-数据交互通道（即相同CMD[ID-Value]和DATA[Type-Value]的组合）即可。例如规定CMD[1-1]获取数据，则该指令对应的数据将按照DATA[1-1]的方式传输到Loice主机，主机只需针对DATA[1-1]编写接收回调函数，而后等待数据到达事件发生即可。

### 4.3 错误处理策略

在基于Loice协议的通信过程中，可能发生诸如指令接收错误、数据接收错误、对端连接断开、收/发数据失败、KAP超时等多种错误，应用程序需要对这些错误进行处理，一般情况下的错误处理策略如下表所示：

<center>

|   错误类型    |  具体错误  |                          处理策略                          |
| :-----------: | :--------: | :--------------------------------------------------------: |
| 指令接收错误  |    所有    |            Loice从机丢弃指令；Loice主机重试发送            |
| 数据接收错误  | 设备ID错误 |      Loice主机丢弃数据并断开连接（设备身份验证失败）       |
| 数据接收错误  |  校验失败  |       Loice从机根据设计忽略错误、断开连接或重传数据        |
| 对端连接断开  |     -      |      丢弃正在发送或接收的数据，重置程序状态，删除会话      |
| 收/发数据失败 |     -      | 丢弃正在发送或接收的数据，重置程序状态，断开连接，删除会话 |
|    KAP超时    |     -      | 丢弃正在发送或接收的数据，重置程序状态，断开连接，删除会话 |

</center>

在应用层协议层面遇到的任何错误都可能导致业务状态的变更，建议在设计时引出所关心错误的异常处理回调，以方便后级程序完成必要的处理动作。

<br/>

## 5 协议功能扩展说明

本章重新审视前文所述协议，对一些特定需求下的协议实现给出建议或参考。

### 5.1 数据帧一对一回应的实现方法

在Loice协议设计原型中，为了方便接收方统一处理，所有协议帧的回应均只有消息首部，因此当Loice从机发起连续的数据帧传输时，数据回应无法给出错误帧的具体信息，在此情况下如需要实现协议层对指定数据帧的重传，可以有两种实现方式：

- 在实现协议时，为数据回应的协议帧增加消息体部分，消息体中带有待重传数据帧的信息，如数据序列号等；

- 开辟专用于重传机制的“指令-数据”通道。使用这种方法，Loice主机可通过指令参数给出待重传数据帧的信息，Loice从机根据指令发起对指定数据帧的重传，此时在抽象层面上重传通道不占用原数据传输通道，程序的结构更加清晰。

### 5.2 重传和流量控制

嵌入式设备可能存在处理性能较低、内存容量有限等问题，当在某流式传输场景下设计应用层重传时，某数据帧的丢失可能导致应用程序在等待该数据帧重传的同时需要缓存其后续传输的数据。由于缓冲区是有限的，因此当缓冲区满但丢失的数据帧仍未重传成功时，必须在停止传输和丢弃数据两种策略中二选一，而上层应用逻辑可能难以获知当前底层的状态，这是通信双方都不愿看到的。

针对这种情况，通信双方可参照TCP的流量控制，规定当前在传但未确认（或正在重传）的数据帧的最大数量，当超出该数量时，发送方的发送API将返回通信受阻的状态信息，以通知应用程序暂停数据传输或在后续时段内减小数据量，以达到自动流量控制的目的。

### 5.3 局域网设备发现

Loice协议是针对局域网内设备间基于TCP的P2P通信设计的，因此Loice协议不对设备发现做任何规定。为了解决Loice从机在动态获取IP时的主从机互联问题，应当单独设计一种基于UDP的设备发现协议，这不在本文范畴。

但考虑到Loice协议的通信需求，当为基于Loice的通信系统添加局域网设备发现功能时，Loice从机需在设备发现回应报文中向Loice主机提供以下信息：

- 当前设备是否处于可连接状态；

    当Loice从机处于可连接状态，则表示：

    - 设备的网络通信正常，设备已经开放默认监听端口；
    - 设备的通信会话数量未达上限，可接受新连接；
    - 设备处于正常的工作模式，可接受新连接；
    - 设备的本地资源可正常获取。

- 当前设备的兼容信息（如Loice协议版本等）；
- 当前设备ID号（可选）；
- 其它连接所需的必要信息。

---

————[ **Loice** by **Turix.Space** ]————
